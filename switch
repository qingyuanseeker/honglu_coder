
private static final Map<String, String> RULE_GROUP_WEATHER_MAP = new HashMap<String, String>();
static 
{
	RULE_GROUP_WEATHER_MAP.put("301992004", "callRate");
	RULE_GROUP_WEATHER_MAP.put("20141203101104540223", "avgCallTime");
	RULE_GROUP_WEATHER_MAP.put("301993009", "satisfy");
	RULE_GROUP_WEATHER_MAP.put("301993005", "oncecallreq");
}

SOHO交换机 | 快速以太网交换机 | 千兆以太网交换机 | 网管交换机  
GbE Switch | 猫 >> 交换机 >> 路由器 
请问如何用交换机共享一个宽带账号:
买个路由器,用路由器WAN口插猫,拨号,路由器LAN口插交换机,交换机挂主机,随便多少台,只要你物理端口够用都能上网

modem是调制解调器,是用来把<[电话线的模拟信号]>转成电脑等的数字信号,
路由器只是一个自动拨号装置加上一个交换机的功能,[电话线上网用猫,网线接口直接用路由器]
如果只用modem的话要电脑上拨号的,电话是不可以和modem直接连接的,不过现在联通的某些宽带<[直接是网线接口]>的,
不用Modem;一般是modem后面接路由器,用路由器自动拨号,电脑和路由器连接,这样的话可以共享上网,不需要主机; 

<[网线能直接上网,电话线需要一个调制解调器拨号才能上网
电话线分2,4,6芯线,网线是8芯线 
网线可以当电话线用,4芯电话线也可以当网线用,2芯电话线只能当电话线用 
电话线是平行线,网线一般是双绞线,电话线一般两芯,网线一般8芯,电话线一般用来传输模拟信号,因为频率低
网线一般用来传输数字信号,因为频率比较高所以用双绞线而且距离不能太远;]>

移动宽带是光纤到家还是直接是网线到家 <[电话线上网 >> 网线到家 >> 光纤到家]>

路由routing是指分组从源到目的地时,决定端到端路径的网络范围的进程,
路由工作在OSI参考模型第三层——网络层的数据包转发设备

数据表设计三大范式: <[每个表中都是一组密切相关的数据]>
第一范式是不可拆分
第二是完全依赖
第三消除传递依赖 

为了建立冗余较小,结构合理的数据库,设计数据库时必须遵循一定的规则,在关系型数据库中这种规则就称为范式,
范式是符合某一种设计要求的总结,要想设计一个结构合理的关系型数据库,必须满足一定的范式,在实际开发中最
为常见的设计范式有三个：

第一范式(确保每列保持原子性)
第一范式是最基本的范式,如果数据表中的所有字段都是不可分解的原子值,就说明数据表满足了第一范式:
第一范式的合理遵循需要根据系统的实际需求来决定,比如某些数据库系统中需要用到"地址"这个属性,本来
直接将"地址"属性设计成一个数据库表的字段就行,但是如果系统经常会访问"地址"属性中的"城市",那么就
非要将"地址"这个属性重新拆分为省份,城市,详细地址等多个部分进行存储,这样对地址中某一个部分操作的
时候就将非常方便,这样的设计才算满足了数据库的第一范式:
<[http://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html]>
上表所示的用户信息遵循了第一范式的要求,这样在对用户使用城市进行分类的时候就非常方便,也提高了数据库的性能;

第二范式(确保表中的每列都和主键相关 >> 特别针对联合主键)
第二范式在第一范式的基础上更近一步,第二范式需要确保数据库表中的每一列都和主键相关,而不能只与主键的某一个
部分(主要针对联合主键),也就是说在一个数据库表中,一个表中只能保存一种数据,不可以把多种数据保存在同一张数据库表中;
<[http://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html]>

第三范式(确保每列都和主键直接相关,而不是间接相关 >> 针对能用外键的情况)
第三范式需要确保数据表中的每一列数据和主键直接相关,而不是间接相关:
比如在设计一个订单数据表的时候,可以将客户的编号作为一个外键和订单表建立<[直接]>相应的关系,而不是在订单表中添加
客户的其它信息<姓名,公司,联系方式>的字段
这样在查询订单信息的时候,就可以使用客户编号来引用客户信息表中的记录,也不必在订单信息表中多次输入客户信息的内容
减小了数据冗余;

kilo (k)* = 10 ^ 3 = 1,000 thousand 千 
mega (M)  = 10 ^ 6 = 1,000,000 million 百万 [卖嘎]
giga (G)  = 10 ^ 9 = 1,000,000,000 billion 十亿 [给嘎]
tera (T)  = 10 ^ 12 = 1,000,000,000,000 trillion 万亿 [踢rA]

安卓手机怎么把软件安装到外置sd卡 >> [豌豆荚][百度经验]
http://jingyan.baidu.com/article/ff42efa9765d85c19e2202e9.html

oracle 常用的开关:
在plsql 里将一条语句导出时候常会出现以下的结果:
prompt importing table t_test
set feedback off
set define off
insert into t_test('1','p&1');
prompt done.

prompt 将显示后面的提示, 相当于一般操作系统命令 echo,输出后面的信息......
set feedback 提供三种方式:
1) set feedback on
2) set feedback off
3) set feedback n
默认的当一条sql 语句发出的时候,oracle 会给一个反馈, 比如说创建表的时候,如果成功,
命令行会返回类似: table created 的反馈,// PL/SQL procedure successfully completed;

<[set define off]>
在SQL*Plus中默认的"&"表示<[替代变量]>也就是说,只要在命令中出现该符号,SQL*Plus就会要你
输入替代值,这就意味着你无法将一个含有该符号的字符串输入数据库或赋给变量,如字符串"SQL&Plus"
系统会理解为以"SQL"打头的字符串,它会提示你输入替代变量Plus的值,如果你输入ABC,则最终字符串转化为"SQLABC" 
set define off 则关闭该功能,"&" 将作为普通字符,如上例,最终字符就为 "SQL&Plus"  

<[set define off]>关闭替代变量功能 
set define on  开启替代变量功能 
set define $   (不是能是字母数字和空格)将替代默认变量标志符"&"为"$"原来的&标志将以普通字符的形式插入
而$后面的字符这会是变量,将会提示你输入;

方法一: 在SQL语句中将'&'替换成chr(38),因为chr(38)是‘&’的ASCII码
SQL> Select 'Tom' || chr(38) || 'Jerry' from dual;
方法二: 分拆原来的字符串
SQL> Select 'Tom' || '&' || 'Jerry' from dual;
备注：如果是在命令行执行,可以设置 "Set define OFF" 之后在正常执行sql语句即可

// 因为开源的力量, java 支持很多对不同文件的操作,不解压直接读zip文件, 
// 读写 excel 表格内容, 收发电子邮件, 执行shell & bash 脚本,加解密 etc.. 
http://daoshud1.iteye.com/blog/2012362  <读 zip 包>
http://fengzheng0603.iteye.com/blog/1668162 <读写 doc 文档>
http://jingyan.baidu.com/article/47a29f243ab71bc01523995a.html <产生 java 帮助文档>

oracle >> 的监听服务已经打开... 但是 telnet 127.0.0.1 1521
数据在通信网络上是以数据包为单位传输的,每个数据包中有表示数据信息和提供数据路由的帧,
这就是说,不管网络情况有多好,数据都不是以线性(就像打电话一样)连续传输的,中间总是有空
洞的,数据包的传输,不可能百分之百的能够完成,因为物理线路故障,设备故障,病毒攻击,路由信
息错误等原因,总会有一定的损失.

// 单例模式的多种写法:
<[http://www.blogjava.net/kenzhh/archive/2013/03/15/357824.html]>
在body中用onload: <<bme:cell colspan="4"></bme:cell>>
1 <body onload="myfunction()"> 
2、在脚本中用window.onload:

<script type="text/javascript"> 
 function myfun() 
 { alert("this window.onload"); } 
 /*用window.onload调用myfun()*/
 window.onload=myfun; // 不要括号 
</script> 

下面这个例子在页面完成加载之后改变id_1的背景颜色。
<script language="javascript" > 
function myfun() 
{ 
  document.getElementById("id_1").style.background= "#000"; 
  // 改变背景颜色 
} 
// 用js实现在加载完成一个页面后自动执行一个方法 
/*用window.onload调用myfun()*/window.onload=myfun;//不要括号 
</script> 

-- 问题,对于include的页面,没等页面渲染完毕层显示出来了,导致页面紊乱;
<!--注意一定是要放在body中-->
<body >
<div id="top_div" style="display:none;">
<%@ include file="show_top.jsp"%>
</div>
<script LANGUAGE="JavaScript">
$("#top_div").css("display", "block");
</script>
</body>

[javascript的脚本放在哪里:]
1): 在HTML body部分中的JavaScripts会在页面加载的时候被执行
2): 在HTML head部分中的JavaScripts会在被调用的时候才执行

JavaScript应放在哪里
[页面中的JavaScripts会在浏览器加载页面的时候被立即执行,我们并不希望总是这样,
有时候我们想让一段脚本在页面加载的时候执行,而有时候我们想在用户触发一个事件
的时候执行脚本]

head 部分中的脚本: [需调用才执行的脚本或事件触发执行的脚本放在HTML的head部
分中,当你把脚本放在head部分中时,可以保证脚本在任何调用之前被加载;]

body 部分中的脚本: 当页面被加载时执行的脚本放在HTML的body部分,放在body部分的
脚本通常被用来生成页面的内容;body 和 head 部分可同时有脚本:你可在文件中放无数
的脚本,因此你的文件中可以在body和head部分同时存在脚本;放入body中,则加载后才运
行javascript的代码;

每一个JSP页面都会被Web容器编译成一个Java类,供web容器调用,并且生成HTML叶面回馈给用户
而了解其中的编译方法和规则,对我们学习JSP是非常有好处的,可以说学习好了这个编译原理,就
已经学习好了大部分的JSP知识剩下的工作就只剩下熟记一些tablib和反复应用以使自己更加熟
练而已了,JSP会被编译成.java放Tomcat/work/Catalina/localhost/***/org/apache/jsp/page
然后编译成.class
jsp = java + html
servlet = java + out.print(html)
1. 客户端发送请求给web容器
2. web容器将jsp首先转译成servlet源代码.java
3. web容器将servlet源代码编译成.class 文件
4. web容器执行.class 文件
5. web容器将结果响应给客户端
\work\Catalina\localhost\ssoc\org\apache\jsp\usl\customization\duedisposedetail\showTimelyDetail_usl$Helper.class
\work\Catalina\localhost\ssoc\org\apache\jsp\usl\customization\duedisposedetail\showTimelyDetail_usl.class
\work\Catalina\localhost\ssoc\org\apache\jsp\usl\customization\duedisposedetail\showTimelyDetail_usl.java
